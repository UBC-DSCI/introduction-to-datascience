# Getting started with Jupyter {#Getting-started-with-Jupyter}

```{r 11-how-to-get-started-using-r, echo = FALSE, message = FALSE, warning = FALSE}
library(magick)
library(magrittr)
library(knitr)
knitr::opts_chunk$set(message = FALSE)
```

## Overview

To be able to effectively and efficiently write R code for your analysis you 
will need access to the R programming language on a computer. This chapter will 
show you how to use the R programming language with a common coding 
platform in data science, Jupyter. In this chapter, we will show you how to use this platform via a web-interface for ease of getting going 
quickly. In a later chapter, we will also show you how to install and configure this on your local computer (i.e., laptop). These skills are essential to getting your analysis running; think of it like getting dressed in the morning!

## Chapter learning objectives

By the end of the chapter, students will be able to:

- use Jupyter to run, edit and write R code
- open and view plain text data files in Jupyter
- create new Jupyter notebooks
- export Jupyter notebooks to other standard file types (e.g., `.html`, `.pdf`)

## Jupyter

Jupyter is a web-based interactive development environment for creating, editing and executing documents called Jupyter notebooks. Jupyter notebooks are documents that contain a mix of computer code (and its output) and formattable text. Given that they combine these two analysis artifacts in a single document—code is not separate from the output or written report—notebooks are one of the leading tools to create reproducible data analyses. Reproducible data analysis is one where you can reliably and easily recreate the same results when analyzing the same data. Although this sounds like something that should always be true of any data analysis, in reality, this is not often the case; one needs to make a conscious effort to perform data analysis in a reproducible manner.

The name Jupyter came from combining the names of the three programming languages that it was initially targeted for (Julia, Python, and R), and now many other languages can be used with Jupyter notebooks.

A Jupyter notebook looks like this:

```{r img-jupyter, echo = FALSE, message = FALSE, warning = FALSE, fig.cap = "A screenshot of a Jupyter Notebook.", fig.retina = 2}
knitr::include_graphics("img/jupyter.png")
```

### Accessing Jupyter

One of the easiest ways to start computing in R with Jupyter is to use a 
web-based platform called JupyterHub that already has Jupyter, R, a number of R packages, and collaboration tools installed, configured and ready to use. 
JupyterHub's are usually created and provisioned by organizations (for example,
a university, a company, *etcetera*) and require authentication to gain 
access. <!--- Insert link to public JupyterHub here if we can get 
access/permission (either 2i2c collaboration, or 
https://notebooks.gesis.org/hub/home) --> Jupyter can also be installed on your
own computer (desktop or laptop), and we provide examples of how to do this in
chapter \@ref(move-to-your-own-machine).

## Code cells

The sections of a Jupyter notebook that contain code in the R programming 
language are referred to as code cells. Running a code cell will execute all of 
the code it contains, and the output (if any exists) will be displayed directly
underneath the code that generated it. Outputs may include printed text or 
numbers, data frames and data visualizations.

```{r code-cell-not-run, echo = FALSE, fig.cap = "A code cell in Jupyter that has not yet been executed. Note the absence of a number inside the square brackets to the left of the cell.", fig.retina = 2, out.width="100%"}
image_read("img/code-cell-not-run.png") %>% 
  image_crop("3632x1000")
```

```{r code-cell-run, echo = FALSE, fig.cap = "A code cell in Jupyter that has been executed. Note the code output beneath the cell (preview of a data frame) and the presence of a number inside the square brackets to the left of the cell. This number indicates the order in which the cells were run.", fig.retina = 2, out.width="100%"}
image_read("img/code-cell-run.png") %>% 
  image_crop("3632x2000")
```


### Executing code cells

Code cells can be run independently or as part of executing the entire notebook using one of the "**Run all**" commands found in the **Run** or **Kernel** menus in Jupyter. Running a single code cell independently is a workflow typically used when editing or 
writing your own R code. Executing an entire notebook is a workflow typically 
used to ensure that your analysis runs in its entirety before sharing it with
others, and when using a notebook as part of an automated process.

To run the a code cell independently, the cell needs to first be activated. This
is done by clicking on it with the cursor. Jupyter will indicate a cell has been
activated by highlighting it with a blue rectangle to its left. After the cell
has been activated, the cell can be run by either pressing the **Run** (▶) 
button in the Jupyter notebook tab menu, or by using a keyboard shortcut of 
`Shift + Enter`.

```{r activate-and-run-button, echo = FALSE, fig.cap = "An activated cell that is ready to be be run. The red arrow points to blue rectangle to the cell's left. The blue rectangle indicates that it is ready to be run. This can be done by clicking the run button (circled in red).", fig.retina = 2, out.width="100%"}
image_read("img/activate-and-run-button-annotated.png") %>% 
  image_crop("3632x900")
```

To execute all of the code cells in an entire notebook, you can either select 
**Run** >> **Run All Cells**, or **Kernel** >> 
**Restart Kernel and Run All Cells...** from the Jupyter menu. Additionally, 
there is a **Restart the kernel, then re-run the whole notebook** button (▶▶) in 
the Jupyter notebook tab menu. All of these commands result in all of the code 
cells in a notebook being run, however only
the **Restart Kernel and Run All Cells...** command and the ▶▶ button will restart 
the R session before running all of the cells. Restarting the R session before 
running all of the cells means that all previous objects that were created from 
running cells before this command was run will be deleted. This command emulates
how your notebook code would run if you completely restarted Jupyter before 
executing your entire notebook.

```{r restart-kernel-run-all, echo = FALSE, fig.cap = "Restarting the R session can be accomplished by clicking Restart Kernel and Run All Cells...", fig.retina = 2, out.width="100%"}
image_read("img/restart-kernel-run-all.png") %>% 
  image_crop("3632x900")
```

> #### The Kernel
> The kernel is a program that executes the code inside your notebook and outputs
> the results. Kernels for many different programming languages have been 
> created for Jupyter, which means that Jupyter can interpret and execute the 
> code of many different programming languages. To run R code, your notebook 
> will need an R kernel. In the top right of your window, you can see a circle 
> that indicates the status of your kernel. If the circle is empty (⚪), 
> the kernel is idle and ready to execute code. If the circle is filled in (⚫), 
> the kernel is busy running some code.
> 
> You may run into problems where your kernel is stuck for an excessive amount 
> of time, your notebook is very slow and unresponsive, or your kernel loses its
> connection. If this happens, try the following steps:
>
> - At the top of your screen, click **Kernel**, then **Interrupt Kernel**.
> - If that doesn't help, click **Kernel**, then **Restart Kernel**.... If you do this, you will have to run your code cells from the start of your notebook up until where you paused your work.
> - If that doesn't help, restart your server. First, save your work by clicking **File** at the top left of your screen, then **Save Notebook**. Next, from the **File** menu click **Hub Control Panel**. Choose **Stop My Server** to shut it down, then the **My Server** button to start it back up. Then, navigate back to the notebook you were working on.

### Creating new code cells

To create a new code cell in Jupyter, click the `+` button in the Jupyter notebook tab menu. By default, all new cells in Jupyter start out as code cells, so after this, all you have to do is write R code within the new cell you just created!

```{r create-new-code-cell, echo = FALSE, fig.cap = "New cells can be created by clicking the + button, and are by default code cells.", fig.retina = 2, out.width="100%"}
image_read("img/create-new-code-cell.png") %>% 
  image_crop("3632x900")
```

## Markdown cells

Rich formatted text cells inside a Jupyter notebook are called Markdown cells.
They get this name because the rich text formatting is specified using a simple
markup language called Markdown. You do not need to learn Markdown to write text
in the Markdown cells in Jupyter, plain text will work just fine. However, you 
might want to eventually learn a bit about the Markdown markup language because 
Markdown formatting allows you to do common things like **bold** and *italicize* 
text, create subject headers, format bullet and numbered lists, and more. 
Teaching the markdown formatting language is beyond the scope of this book. 
However, If you are keen to learn more, a good place to
start is this [cheatsheet](https://commonmark.org/help/) and this 
[tutorial](https://commonmark.org/help/tutorial/).

### Editing Markdown cells

To edit a Markdown cell in Jupyter, you need to double click on any Markdown 
cell and the unformatted (we call this unrendered) version of the text will be
shown. You can then use your keyboard to edit the text. To view the formatted
(we call this rendered) text, click the **Run** (▶) button in the Jupyter 
notebook tab menu, or use the `Shift + Enter` keyboard shortcut.

```{r markdown-cell-not-run, echo = FALSE, fig.cap = "A Markdown cell in Jupyter that has not yet been rendered and can be edited.", fig.retina = 2, out.width="100%"}
image_read("img/markdown-cell-not-run.png") %>% 
  image_crop("3632x900")
```

```{r markdown-cell-run, echo = FALSE, fig.cap = "A Markdown cell in Jupyter that has been rendered and exhibits rich text formatting. ", fig.retina = 2, out.width="100%"}
image_read("img/markdown-cell-run.png") %>% 
  image_crop("3632x900")
```

### Creating new Markdown cells

To create a new Markdown cell in Jupyter, click the `+` button in the Jupyter 
notebook tab menu. By default, all new cells in Jupyter start as code cells, so the cell format needs to be changed to be recognized and rendered as a Markdown cell. To do this, click on the cell with your cursor to 
ensure it is activated, and then click on the drop-down box next to the 
**Restart the kernel, then re-run the whole notebook** button (▶▶) in the 
Jupyter notebook tab menu and changing it from "**Code**" to "**Markdown**".

```{r convert-to-markdown-cell, echo = FALSE, fig.cap = "New cells are by default code cells. To create Markdown cells, the cell format must be changed.", fig.retina = 2, out.width="100%"}
image_read("img/convert-to-markdown-cell.png") %>% 
  image_crop("3632x900")
```

## Saving your work

As with any file you work on, it is critical to save your work often so you 
don't lose your progress! Jupyter has an autosave feature, where open files are 
saved periodically. The default for this is every two minutes. You can also 
manually save a Jupyter notebook by selecting **Save Notebook** from the 
File menu, by clicking the dick icon on the tab menu of the Jupyter notebook,
or by using a keyboard shortcut (`Control + S` for Windows, or `Command + S` for
Mac OS). 

## Best practices for running a notebook

### Best practices for executing code cells

As you might know (or at least imagine) by now, Jupyter notebooks are great for
interactively editing, writing and running R code - this is what they were 
designed for. Consequently, Jupyter notebooks are flexible in regards to code cell execution order. This flexibility means that code cells can be run in any arbitrary order using the **Run** (▶) button. This flexibility has a downside since it can lead to Jupyter notebooks whose code cannot be executed in a linear order (from top to bottom of the notebook). A non-linear notebook is problematic because a linear order is the conventional way code documents are run, and others will have this expectation when running your notebook. Finally, if the code is used in some automated process, it will need to run in a linear order, from top to bottom of the notebook.

Even with the best intentions of writing a Jupyter notebook whose code can be 
executed in a linear order, the flexibility of the Jupyter notebook can 
sometimes allow us to misstep and fail to rise to our intentions. The is most 
often due to relying solely on using the ▶ button to execute cells. It is 
possible to create a non-linear Jupyter notebook
because named R objects (*e.g.,* a data frame named `my_data`) are created 
when a cell is run, they can be referenced in another distinct code cell, and 
they continue to exist for the entire session the notebook is open. They will 
only cease to exist if they are deliberately deleted
with R code, or when the Jupyter notebook R session (*i.e.*, kernel) is stopped 
or restarted. This means that objects that were created in a cell, can be 
referenced in a cell above without error, as long as the user runs the cells in
that particular, non-conventional order. Additionally, a user can create objects
through running a cell, which later gets deleted. Meaning that that object only
existed for that one particular R session and would not exist again if the 
notebook session was restarted and the notebook run again.

```{r out-of-order-1, echo = FALSE, fig.cap = "Code that was written out of order, but not yet executed.", fig.retina = 2, out.width="100%"}
image_read("img/out-of-order-1.png") %>% 
  image_crop("3632x800")
```

```{r out-of-order-2, echo = FALSE, fig.cap = "Code that was written out of order, and was executed using the run button in a non-linear error without error. The order of execution can be traced by following the numbers to the left of the code cells; their order indicates the order in which the cells were executed.", fig.retina = 2, out.width="100%"}
image_read("img/out-of-order-2.png") %>% 
  image_crop("3632x800")
```

```{r out-of-order-3, echo = FALSE, fig.cap = 'Code that was written out of order, and was executed in a linear order using "Restart Kernel and Run All Cells..." This resulted in an error at the execution of the second code cell and it failed to run all code cells in the notebook.', fig.retina = 2, out.width="100%"}
image_read("img/out-of-order-3.png") %>% 
  image_crop("3632x800")
```

These events may not negatively affect the user of that current R session, but 
they will negatively affect others that try to run 
that notebook, including the user that created that notebook in a future R 
session. Regularly, and intentionally executing the entire notebook in
a fresh R session will help guard against this by 
letting a user know that some aspect of the code does not allow the notebook to be run linearly. Knowing this sooner than later
will allow the user to fix the issue quickly, ideally within
that session. We recommend doing this at least 2-3 times within any work session
on a Jupyter notebook.

### Best practices for including R packages in notebooks

Most data analyses these days depend on functions from external R packages that
are not built-in to R. One example of this is the `tidyverse` metapackage that 
we heavily rely on in this book. It provides us access to functions like 
`read_csv` for reading data, `select` for subsetting columns, and `ggplot` for 
creating high-quality graphics. 

As mentioned earlier in the book, external R packages need to be loaded before
the functions they contain can be used. Our recommended way to do this is via 
`library(package_name)`. But where should this line of code be written in a 
Jupyter notebook? One idea could be to load the library right before the 
function is used in the notebook. However, although this technically works, this
causes hidden, or at least non-obvious, R package dependencies when others view
or try to run the notebook. These hidden dependencies can lead to errors when 
the notebook is executed on another computer if the needed R packages are not
installed. Additionally, if the data analysis code takes a long time to run, 
uncovering the hidden dependencies that need to be installed so that the 
analysis can run without error can take a great deal of time to uncover.

To avoid this, it is highly recommended that all R packages are loaded in a code
cell near the top of the Jupyter notebook. Doing this not only ensures that all 
packages are loaded before their functions are called (assuming the notebook is
run in a linear order from top to bottom, as recommended above), but also makes
it easy for others wanting to view or run the notebook, to understand what 
external R packages were used in the data analysis, and hence, what R packages
they would have to ensure are installed on their computer to successfully run 
the analysis.

## Exploring data files

It is essential to preview data files before you try to read them into R to see whether or not there are column names, what the delimiters are, and if there are lines you need to skip. In Jupyter, you preview data files stored as plain text files (e.g., comma- and tab-separated files) in their plain text format by right-clicking on the file's name in the Jupyter file explorer and selecting **Open with** and then selecting **Editor**. Suppose you do not specify to open the data file with an editor. In that case, Jupyter will render a nice table for you, and you will not be able to see the column delimiters, and therefore you will not know which function to use, nor which arguments to use and values to specify for them.

```{r open-data-w-editor-01, echo = FALSE, fig.cap = "Opening data files with an editor in Jupyter.", fig.retina = 2, out.width="100%"}
image_read("img/open_data_w_editor_01.png") %>% 
  image_crop("3632x2000")
```

```{r open-data-w-editor-02, echo = FALSE, fig.cap = "A data file as viewed in an editor in Jupyter.", fig.retina = 2, out.width="100%"}
image_read("img/open_data_w_editor_02.png") %>% 
  image_crop("3632x2000")
```

## Exporting to a different file format 

In Jupyter, viewing, editing and running R code is done in the Jupyter notebook (file extension `.ipynb`) file format. This file format is not easy to open and view outside of Jupyter. Thus, to share your analysis with people who do not commonly use Jupyter, it is recommended that you export your executed analysis as a more common file type, such as an `.html` file, or a `.pdf`. We recommend exporting the Jupyter notebook after executing the analysis so that you can also share the outputs of your code.

The `.html` file format will result in a shareable file that anyone can open using a web browser (*e.g.,* Firefox, Safari, Chrome, Edge, *etc.*). It will result in a document that is visually similar to what the Jupyter notebook looked like inside Jupyter. One point of caution here is that if there are images in your Jupyter notebook, you will need to share the image files and the `.html` file to see them.

The `.pdf` file format will result in a shareable file that anyone can open using many programs, including Adobe Acrobat, Preview, web browsers and many more. The benefit of exporting to PDF is that it is a standalone document, even if the Jupyter notebook included references to image files. The conventional route for exporting Jupyter notebooks to `.pdf` files depends on a powerful tool called LaTeX. The default settings will result in a document that visually looks quite different from what the Jupyter notebook looked like inside Jupyter regarding font and page margins. The formatting can be customized, however, this requires some learning of the LaTeX markup language. 

## Creating a new Jupyter notebook

At some point, you will want to create a new, fresh Jupyter notebook for your own project instead of viewing, running or editing a notebook that was started by someone else. To do this, navigate to the **Launcher** tab, and click on the R icon under the **Notebook** heading. If no **Launcher** tab is visible, you can get a new one via clicking the **+** button at the top of the Jupyter file explorer. 

```{r launcher, echo = FALSE, fig.cap = "Clicking on the R icon under the Notebook heading will create a new Jupyter notebook with an R kernel.", fig.retina = 2, out.width="100%"}
image_read("img/launcher-annotated.png") %>% 
  image_crop("3632x2000")
```


Once you have created a new Jupyter notebook, be sure to give it a descriptive name, as the default file name is `Untitle.ipynb`. You can rename files by right-clicking on the file name of the Jupyter notebook you just created and click **Rename**. This will make the file name editable. Use your keyboard to change the name. Pressing `Enter` or clicking anywhere else in the Jupyter the interface will save the changed file name.

We recommend not using white space or non-standard characters in file names. 
Doing so will not prevent you from using that file in Jupyter. However, these sorts of things become troublesome as you start to do more advanced data science projects that involve repetition and automation. We recommend naming files using lower case characters and separating words by a dash (`-`) or an underscore (`_`).

## Additional resources
- The [JupyterLab Documentation](https://jupyterlab.readthedocs.io/en/latest/)
